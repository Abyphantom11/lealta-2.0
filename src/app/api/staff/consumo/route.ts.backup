import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '../../../../lib/prisma';
import { z } from 'zod';
import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';
import { geminiAnalyzer } from '../../../../lib/ai/gemini-analyzer';
import fs from 'fs';

// Forzar renderizado din√°mico para esta ruta que usa autenticaci√≥n
export const dynamic = 'force-dynamic';

// Funciones auxiliares para simplificar el c√≥digo principal

// Helper function to get or create default location
async function getOrCreateDefaultLocation(businessId?: string): Promise<string> {
  // Try to find an existing location
  let location = await prisma.location.findFirst({
    where: businessId ? { businessId } : {},
  });

  // If no location exists, create a default one
  if (!location) {
    // If no businessId provided, try to get the first business or create one
    let business;
    businessId ??= (await prisma.business.findFirst())?.id;
    
    if (!businessId) {
      business = await prisma.business.create({
        data: {
          name: 'Negocio Principal',
          slug: 'negocio-principal',
          subdomain: 'principal',
        },
      });
      businessId = business.id;
    }

    location = await prisma.location.create({
      data: {
        businessId: businessId,
        name: 'Ubicaci√≥n Principal',
      },
    });
  }

  return location.id;
}

// Helper function to validate form data
function validateFormData(formData: FormData) {
  const image = formData.get('image') as File;
  const cedula = formData.get('cedula') as string;
  const locationId = formData.get('locationId') as string;
  const empleadoId = (formData.get('empleadoId') as string) || 'system';

  // Validate required fields
  if (!image || !cedula || !locationId) {
    return {
      error: 'Faltan campos requeridos: image, cedula, locationId',
      status: 400
    };
  }

  // Validate image
  if (!image.type.startsWith('image/')) {
    return {
      error: 'El archivo debe ser una imagen',
      status: 400
    };
  }

  if (image.size > 5 * 1024 * 1024) { // 5MB limit
    return {
      error: 'La imagen no puede superar 5MB',
      status: 400
    };
  }

  return {
    data: { image, cedula, locationId, empleadoId },
    error: null
  };
}

// Helper function to save image
async function saveImageFile(image: File): Promise<{ filepath: string; publicUrl: string }> {
  const bytes = await image.arrayBuffer();
  const buffer = Buffer.from(bytes);

  // Create uploads directory if it doesn't exist
  const uploadsDir = join(process.cwd(), 'public', 'uploads');
  try {
    await mkdir(uploadsDir, { recursive: true });
  } catch (error) {
    console.error('Error creating uploads directory:', error);
    // Directory might already exist, continue
  }

  // Generate unique filename
  const timestamp = Date.now();
  const extension = image.name.split('.').pop();
  const filename = `ticket_${timestamp}.${extension}`;
  const filepath = join(uploadsDir, filename);
  const publicUrl = `/uploads/${filename}`;

  await writeFile(filepath, buffer);
  
  return { filepath, publicUrl };
}

// Helper function to process image with Gemini AI
async function processImageWithGemini(filepath: string): Promise<{
  ocrText: string;
  productos: Array<{ name: string; price?: number; line: string }>;
  total: number;
  empleadoDetectado: string;
  confianza: number;
}> {
  try {
    // Read image file
    const imageBuffer = fs.readFileSync(filepath);
    const mimeType = 'image/jpeg'; // Asumimos JPEG por simplicidad

    console.log('ü§ñ Procesando imagen con Gemini AI...');
    
    // Analizar con Gemini
    const analysis = await geminiAnalyzer.analyzeImage(imageBuffer, mimeType);
    
    console.log('‚úÖ An√°lisis completado:', {
      total: analysis.total,
      productos: analysis.productos.length,
      confianza: analysis.confianza,
      empleado: analysis.empleado
    });

    // Convertir formato para compatibilidad
    const productos = analysis.productos.map((p) => ({
      name: p.nombre,
      price: p.precio,
      line: `${p.nombre} x${p.cantidad} - $${p.precio}`
    }));

    return {
      ocrText: `Gemini AI - An√°lisis completado con confianza: ${(analysis.confianza * 100).toFixed(1)}%`,
      productos,
      total: analysis.total,
      empleadoDetectado: analysis.empleado || 'No detectado',
      confianza: analysis.confianza
    };

  } catch (error) {
    console.error('‚ùå Error en procesamiento con Gemini:', error);
    
    // Fallback values si falla el an√°lisis
    return {
      ocrText: 'Error en procesamiento autom√°tico',
      productos: [
        {
          name: 'Producto fallback',
          price: 25.50,
          line: 'Error: An√°lisis manual requerido'
        }
      ],
      total: 25.50,
      empleadoDetectado: 'No detectado',
      confianza: 0.1
    };
  }
}

// Function for basic OCR analysis (deprecated)
function performBasicOCRAnalysis(text: string): {
  total: number;
  productos: Array<{ name: string; price?: number; line: string }>;
} {
          .replace(/```/g, '')
          .trim();
        
        // Try to parse AI response
        const aiData = JSON.parse(cleanedResponse);
        
        if (aiData.total && typeof aiData.total === 'number') {
          total = aiData.total;
        }
        
        if (aiData.productos && Array.isArray(aiData.productos)) {
          productos = aiData.productos.map((p: any, index: number) => ({
            name: p.name || `Producto ${index + 1}`,
            price: typeof p.price === 'number' ? p.price : 0,
            line: p.line || p.name || `L√≠nea ${index + 1}`
          }));
        }

        // Store detected employee for confirmation
        empleadoDetectado = aiData.empleado || 'No detectado';
        ocrText = `IA Visual: Procesado exitosamente con Gemini Vision`;

        console.log('‚úÖ Gemini Vision analysis successful:', {
          total,
          productos: productos.length,
          empleado: empleadoDetectado
        });
        
      } catch (aiError) {
        console.log('‚ö†Ô∏è Gemini Vision failed, using fallback:', aiError);
        // Fall back to demo values
        total = 25.5;
        productos = [
          {
            name: 'Producto detectado',
            price: total,
            line: 'Procesamiento visual fallback',
          },
        ];
        empleadoDetectado = 'No detectado';
        ocrText = 'Fallback: Error en procesamiento visual';
      }
    } else {
      // No AI available, use demo values
      console.log('‚ö†Ô∏è No AI available, using demo values');
      total = 25.5;
      productos = [
        {
          name: 'Producto demo',
          price: total,
          line: 'Demo: No AI disponible',
        },
      ];
    }

  } catch (error) {
    console.error('Error en procesamiento de imagen:', error);
    // Fallback values if processing fails
    ocrText = 'Error en procesamiento de imagen';
    total = 25.5; // Fallback amount
    productos = [
      {
        name: 'Producto fallback',
        price: total,
        line: 'Error: Procesamiento fallback',
      },
    ];
  }

  return { ocrText, productos, total, empleadoDetectado };
}

// Function for basic OCR analysis
function performBasicOCRAnalysis(text: string): {
  total: number;
  productos: Array<{ name: string; price?: number; line: string }>;
} {
  let total = 0;
  let productos: { name: string; price?: number; line: string }[] = [];

  // Simple heuristic to extract total (look for patterns like $XX.XX or TOTAL: XX.XX)
  const totalRegex = /(?:total|sum|suma|precio)[:\s]*\$?(\d+(?:[.,]\d{2})?)/i;
  const totalMatches = totalRegex.exec(text);
  if (totalMatches) {
    total = parseFloat(totalMatches[1].replace(',', '.'));
  }

  // Try to extract product lines (very basic heuristic)
  const lines = text.split('\n').filter(line => line.trim().length > 0);
  productos = lines
    .filter(line => /\$?\d+(?:[.,]\d{2})?/.test(line))
    .slice(0, 10) // Limit to first 10 potential products
    .map((line, index) => {
      const priceRegex = /\$?(\d+(?:[.,]\d{2})?)/;
      const priceMatch = priceRegex.exec(line);
      const price = priceMatch
        ? parseFloat(priceMatch[1].replace(',', '.'))
        : 0;
      return {
        name:
          line.replace(/\$?\d+(?:[.,]\d{2})?/g, '').trim() ||
          `Producto ${index + 1}`,
        price: price,
        line: line.trim(),
      };
    });

  // If no total was found, sum up product prices
  if (total === 0 && productos.length > 0) {
    total = productos.reduce(
      (sum, p: { price?: number }) => sum + (p.price ?? 0),
      0
    );
  }

  return { total, productos };
}

export async function POST(request: NextRequest) {
  console.log('üöÄ Iniciando procesamiento de ticket con IA...');
  
  try {
    const formData = await request.formData();

    // Validate and extract form data
    const validation = validateFormData(formData);
    if (validation.error) {
      console.log('‚ùå Error de validaci√≥n:', validation.error);
      return NextResponse.json({ error: validation.error }, { status: validation.status });
    }

    const { image, cedula } = validation.data!;
    console.log('‚úÖ Datos validados - Cedula:', cedula, 'Imagen:', image.name);

    // Find client
    console.log('üîç Buscando cliente...');
    const cliente = await prisma.cliente.findUnique({
      where: { cedula: cedula },
    });

    if (!cliente) {
      console.log('‚ùå Cliente no encontrado:', cedula);
      return NextResponse.json(
        { error: 'Cliente no encontrado. Debe estar registrado primero.' },
        { status: 404 }
      );
    }

    console.log('‚úÖ Cliente encontrado:', cliente.nombre);

    // Get or create default location
    console.log('üè¢ Obteniendo ubicaci√≥n...');
    const actualLocationId = await getOrCreateDefaultLocation(cliente.businessId ?? undefined);

    // Save image to public/uploads
    console.log('üíæ Guardando imagen...');
    const { filepath, publicUrl } = await saveImageFile(image);
    console.log('‚úÖ Imagen guardada en:', publicUrl);

    // Perform OCR and process with AI
    console.log('ü§ñ Iniciando OCR y procesamiento con IA...');
    const { ocrText, productos, total, empleadoDetectado } = await processImageWithAI(filepath);
    console.log('‚úÖ IA completada - Total:', total, 'Productos:', productos.length, 'Empleado:', empleadoDetectado);

    // Calculate points (basic: 1 point per dollar)
    const puntos = Math.floor(total);

    // Instead of creating the consumo immediately, return data for confirmation
    return NextResponse.json({
      success: true,
      requiresConfirmation: true,
      empleadoDetectado: empleadoDetectado || 'No detectado',
      total: total,
      puntos: puntos,
      productos: productos,
      ocrText: ocrText,
      ticketImageUrl: publicUrl,
      locationId: actualLocationId, // Include for confirmation API
      cliente: {
        nombre: cliente.nombre,
        puntosActuales: cliente.puntos,
        puntosNuevos: cliente.puntos + puntos,
      },
      message: 'Ticket procesado por IA. Confirma los datos antes de registrar.',
    });
  } catch (error) {
    console.error('Consumo registration error:', error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Datos inv√°lidos', details: error.issues },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    );
  }
}
